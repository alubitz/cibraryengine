/*======================================================================

	Animation file data structures 
	Copyright 1997-2003 Epic Games, Inc. All Rights Reserved.

========================================================================*/

typedef char ANSICHAR;
typedef unsigned short _WORD;

// Stub to outline FQuat, which we won't fully define here...
class FQuat
{
public:
	FLOAT X,Y,Z,W;
};

// 
class FVector
{
public:
	FLOAT X,Y,Z;
};


// A bone: an orientation, and a position, all relative to their parent.
struct VJointPos
{
	FQuat   	Orientation;  //
	FVector		Position;     //  

	FLOAT       Length;       //  For collision testing / debugging drawing.  (unused)
	FLOAT       XSize;
	FLOAT       YSize;
	FLOAT       ZSize;
};


// Binary animation info format - used to organize raw animation keys into FAnimSeqs on rebuild
// Similar to MotionChunkDigestInfo..
struct AnimInfoBinary
{
	ANSICHAR Name[64];     // Animation's name
	ANSICHAR Group[64];    // Animation's group name	

	INT TotalBones;           // TotalBones * NumRawFrames is number of animation keys to digest.

	INT RootInclude;          // 0 none 1 included 	(unused)
	INT KeyCompressionStyle;  // Reserved: variants in tradeoffs for compression.
	INT KeyQuotum;            // Max key quotum for compression	
	FLOAT KeyReduction;       // desired 
	FLOAT TrackTime;          // explicit - can be overridden by the animation rate
	FLOAT AnimRate;           // frames per second.
	INT StartBone;            // - Reserved: for partial animations (unused)
	INT FirstRawFrame;        //
	INT NumRawFrames;         // NumRawFrames and AnimRate dictate tracktime...
};


// File header structure. 
struct VChunkHeader
{
	ANSICHAR    ChunkID[20];  // String ID of up to 19 chars (usually zero-terminated)
	INT			TypeFlag;     // Flags/reserved
   	INT         DataSize;     // Size per struct following;
	INT         DataCount;    // Number of structs/
};

// Raw data material.
struct VMaterial
{
	ANSICHAR    MaterialName[64];
	INT			TextureIndex;  // Texture index ('multiskin index')
	DWORD		PolyFlags;     // ALL poly's with THIS material will have this flag.
	INT	        AuxMaterial;   // Reserved: index into another material, eg. detailtexture/shininess/whatever.
	DWORD		AuxFlags;      // Reserved: auxiliary flags 
	INT			LodBias;       // Material-specific lod bias (unused)
	INT			LodStyle;      // Material-specific lod style (unused)
};


// Raw data bone.
struct VBone
{
	ANSICHAR    Name[64];     //
	DWORD	    Flags;        // Reserved.
	INT 	    NumChildren;  // Children  (not used.)
	INT         ParentIndex;  // 0/NULL if this is the root bone.  
	VJointPos   BonePos;      // Reference position.
};


// Binary bone format to deal with raw animations as generated by various exporters.
struct FNamedBoneBinary
{
	ANSICHAR   Name[64];	// Bone's name
	DWORD      Flags;		// reserved
	INT        NumChildren; //
	INT		   ParentIndex;	// 0/NULL if this is the root bone.  
	VJointPos  BonePos;	    //
};

// Raw data bone influence.
struct VRawBoneInfluence // Just weight, vertex, and Bone, sorted later.
{
	FLOAT Weight;
	INT   PointIndex;
	INT   BoneIndex;
};

// An animation key.
struct VQuatAnimKey
{
	FVector		Position;           // Relative to parent.
	FQuat       Orientation;        // Relative to parent.
	FLOAT       Time;				// The duration until the next key (end key wraps to first...)
};

// Vertex with texturing info, akin to Hoppe's 'Wedge' concept - import only.
struct VVertex
{
	_WORD	PointIndex;	 // Index into the 3d point table.
	FLOAT   U,V;         // Texture U, V coordinates.
	BYTE    MatIndex;    // At runtime, this one will be implied by the face that's pointing to us.
	BYTE    Reserved;    // Top secret.
};

// Points: regular FVectors 
struct VPoint
{	
	FVector			Point; 
};

// Textured triangle.
struct VTriangle
{
	_WORD   WedgeIndex[3];	 // Point to three vertices in the vertex list.
	BYTE    MatIndex;	     // Materials can be anything.
	BYTE    AuxMatIndex;     // Second material (unused).
	DWORD   SmoothingGroups; // 32-bit flag for smoothing groups.
};


struct VScaleAnimKey
{	
	FVector ScaleVector;   // If uniform scaling is required, just use the X component..
	FLOAT   Time;          // disregarded	
};

