uniform	sampler2D		texture;
uniform	vec3			chunk_pos;

varying	vec3			normal, position;
varying	vec3			input_normal, vertex;
varying	float			mat_weight;

const	float			ambient_amount = 0.2;const	float			tile_size = 10.0;

vec4 sampleTriplanar(sampler2D texture, vec3 sample_xyz)
{
	vec4 x_sample = texture2D(texture, sample_xyz.yz);
	vec4 y_sample = texture2D(texture, sample_xyz.xz);
	vec4 z_sample = texture2D(texture, sample_xyz.xy);

	vec3 axis_coeffs = input_normal * input_normal;			// not sure if this is more or less efficient than doing abs() of the components

	return (x_sample * axis_coeffs.x + y_sample * axis_coeffs.y + z_sample * axis_coeffs.z) / (axis_coeffs.x + axis_coeffs.y + axis_coeffs.z);
}

void main()
{
	float distance = length(position);
	vec3 uPos = position / distance;
	vec3 uLight = normalize(gl_LightSource[0].position.xyz);

	vec3 uNorm = normalize(normal);
	float light = max(min(1.0, dot(uNorm, uLight)), ambient_amount);

	vec3 sample_xyz = (vertex + chunk_pos) / tile_size;

	vec4 diffuse_sample = sampleTriplanar(texture, sample_xyz);
	vec3 base_color = diffuse_sample.xyz * light;

	gl_FragColor.xyz = base_color * mat_weight;
	gl_FragColor.w = 1.0;
}
