
uniform float timestep;


uniform samplerBuffer	constraint_data;

attribute float			constraint_data_index;		// index into the above
int						data_index;					// the same, but converted to an integer



uniform int				num_rigid_bodies;

uniform samplerBuffer	velocity_data;
uniform samplerBuffer	mass_infos;

attribute vec2			object_indices;				// indices into the above
int						index_a, index_b;			// the same, but converted to integers



varying vec4 out_rot_a;
varying vec4 out_rot_b;

varying vec4 out_vel_a;
varying vec4 out_vel_b;

vec3 vel_a, vel_b, rot_a, rot_b;					// working with vec3 internally, for syntactic simplicity




struct MassInfo
{
	float inv_mass;
	vec3 com;
	mat3 inv_moi;
} massinfo_a, massinfo_b;

MassInfo get_mass_info(int index)
{
	vec4 first_sample = texelFetch(mass_infos, index * 4);

	MassInfo result;
	result.inv_mass =	first_sample.x;
	result.com =		first_sample.yzw;
	result.inv_moi =	mat3(texelFetch(mass_infos, index * 4 + 1), texelFetch(mass_infos, index * 4 + 2), texelFetch(mass_infos, index * 4 + 3).x);

	return result;
}




struct JointConstraint
{
	vec3 desired_dv;
	vec3 apply_pos;
	vec4 a_to_b;									// quaternion; b_to_a can be computed as the inverse of a_to_b

	mat3 oriented_axes;
	vec3 min_extents, max_extents;	mat3 net_moi;									// alpha_to_obja = obj_a->inv_moi * net_moi; alpha_to_objb = obj_b->inv_moi * net_moi;
} jc;

void get_joint_constraint(int index, vec4 first_sample)
{
	vec4 other_samples[8] =
	{
		texelFetch(constraint_data, index + 1),
		texelFetch(constraint_data, index + 2),
		texelFetch(constraint_data, index + 3),
		texelFetch(constraint_data, index + 4),
		texelFetch(constraint_data, index + 5),
		texelFetch(constraint_data, index + 6),
		texelFetch(constraint_data, index + 7),
		texelFetch(constraint_data, index + 8)		// other_samples[7].w is unused
	};

	jc.desired_dv =		first_sample.yzw;	jc.apply_pos =		other_samples[0].xyz;
	jc.a_to_b =			other_samples[3];

	jc.oriented_axes =	mat3(other_samples[0].w, other_samples[1], other_samples[2]);	jc.min_extents =	other_samples[4].xyz;
	jc.max_extents =	other_samples[7].xyz;

	jc.net_moi =		mat3(other_samples[4].w, other_samples[5], other_samples[6]);
}

void process_joint_constraint(vec4 data_sample)
{
	get_joint_constraint(data_index, data_sample);

	// TODO: port JointConstraint::DoConstraintAction from C++ to GLSL
}




struct ContactPoint
{
	vec3 position;
	vec3 normal;
	vec3 r1, r2, nr1, nr2;

	float use_mass;
	float bounce_coeff;
	float fric_coeff;
} cp;

void get_contact_point(int index, vec4 first_sample)
{
	vec4 other_samples[5] =
	{
		texelFetch(constraint_data, index + 1),
		texelFetch(constraint_data, index + 2),
		texelFetch(constraint_data, index + 3),
		texelFetch(constraint_data, index + 4),		// other_samples[3].w is unused
		texelFetch(constraint_data, index + 5)		// other_samples[4].w is unused
	};

	cp.position =		other_samples[4].xyz;
	cp.normal =			other_samples[0].xyz;
	cp.r1 =				other_samples[1].xyz;
	cp.r2 =				other_samples[2].xyz;
	cp.nr1 =			other_samples[3].xyz;
	cp.nr2 = 			vec3(other_samples[0].w, other_samples[1].w, other_samples[2].w);
	cp.use_mass = 		first_sample.y;
	cp.bounce_coeff =	first_sample.z;
	cp.fric_coeff =		first_sample.w;
}

vec3	cp_get_relative_local_velocity()	{ return vel_b - vel_a + cross(cp.r2, rot_b) - cross(cp.r1, rot_a); }

float	cp_get_inward_velocity()			{ return dot(vel_a - vel_b, cp.normal) + dot(rot_a, cp.nr1) - dot(rot_b, cp.nr2); }

float	cp_get_use_mass(vec3 direction)
{
	vec3 nr1 = cross(direction, cp.position - massinfo_a.com);
	vec3 nr2 = cross(direction, cp.position - massinfo_b.com);
	return massinfo_a.inv_mass + massinfo_b.inv_mass + dot(massinfo_a.inv_moi * nr1, nr1) + dot(massinfo_b.inv_moi * nr2, nr2);
}
void	cp_apply_impulse(vec3 impulse)
{
	vel_a += impulse * massinfo_a.inv_mass;
	rot_a += massinfo_a.inv_moi * cross(impulse, cp.r1);

	vel_b -= impulse * massinfo_b.inv_mass;
	rot_b -= massinfo_b.inv_moi * cross(impulse, cp.r2);
}

void process_contact_point(vec4 data_sample)
{
	get_contact_point(data_index, data_sample);

	vec3 dv = cp_get_relative_local_velocity();
	float nvdot = dot(cp.normal, dv);
	if(nvdot < 0.0)
	{
		float impulse_mag = cp.bounce_coeff * cp_get_inward_velocity() * cp.use_mass;
		if(impulse_mag < 0.0)
		{
			vec3 impulse = cp.normal * impulse_mag;

			// normal force
			if(true)		// TODO: have a condition maybe?
			{
				cp_apply_impulse(impulse);				dv = cp_get_relative_local_velocity();
				nvdot = dot(cp.normal, dv);
			}			vec3 t_dv = dv - cp.normal * nvdot;
			float t_dv_mag = length(t_dv);
			// linear friction (kinetic)
			if(t_dv_mag > 0.0)
			{
				float inv_tdmag = 1.0 / t_dv_mag;
				float use_mass2 = cp_get_use_mass(t_dv * inv_tdmag);

				cp_apply_impulse(t_dv * min(use_mass2, abs(impulse_mag * cp.fric_coeff * inv_tdmag)));
			}
		}
	}
}




vec3 get_vel(int index) { return texelFetch(velocity_data, index + num_rigid_bodies).xyz; }
vec3 get_rot(int index) { return texelFetch(velocity_data, index).xyz; }

void main()
{
	index_a = int(object_indices[0]);
	index_b = int(object_indices[1]);

	vel_a = get_vel(index_a);
	rot_a = get_rot(index_a);

	vel_b = get_vel(index_b);
	rot_b = get_rot(index_b);

	massinfo_a = get_mass_info(index_a);
	massinfo_b = get_mass_info(index_b);

	data_index = int(constraint_data_index);

	vec4 data_sample = texelFetch(constraint_data, data_index);

	if(data_sample.x > 0)
		process_contact_point   (data_sample);
	else
		process_joint_constraint(data_sample);

	out_vel_a.xyz = vel_a;
	out_vel_b.xyz = vel_b;
	out_rot_a.xyz = rot_a;
	out_rot_b.xyz = rot_b;
}
