
#define ENFORCE_JOINT_ROTATION_LIMITS 1

const float JC_DV_COEFF = 1.0;


uniform float timestep;

uniform samplerBuffer	constraint_data;

uniform int				num_rigid_bodies;

uniform samplerBuffer	velocity_data;
uniform samplerBuffer	mass_infos;



attribute float			constraint_data_index;		// index into the above (+1 so that zero can denote "no change")
int						data_index;					// the same, but converted to an integer

attribute vec2			object_indices;				// indices of the two constrained objects (one of these should equal (gl_VertexID % num_rigid_bodies))
int						index_a, index_b;			// the same, but converted to integers





varying vec4 out_rot;
varying vec4 out_vel;

vec3 vel_a, vel_b, rot_a, rot_b;					// working with vec3 internally, for syntactic simplicity




vec4 quat_multiply(vec4 a, vec4 b)
{
	return vec4(	a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
					a.w * b.y + a.y * b.w + a.z * b.x - a.x * b.z,
					a.w * b.z + a.z * b.w + a.x * b.y - a.y * b.x,
					a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z);
}

vec4 quat_from_scaled_axis(vec3 axis)	{ float mag = length(axis), half_angle = mag * 0.5; return vec4(axis * (sin(half_angle) / mag), cos(half_angle)); }

vec3 quat_to_scaled_axis(vec4 quat)		{ float mag = length(quat.xyz), half_angle = atan(mag / quat.w); return quat.xyz * (2.0 * half_angle / mag); }



struct MassInfo
{
	float inv_mass;
	vec3 com;
	mat3 inv_moi;
} massinfo_a, massinfo_b;

MassInfo get_mass_info(int index)
{
	vec4 first_sample = texelFetch(mass_infos, index * 4);

	MassInfo result;
	result.inv_mass =	first_sample.x;
	result.com =		first_sample.yzw;
	result.inv_moi =	mat3(texelFetch(mass_infos, index * 4 + 1), texelFetch(mass_infos, index * 4 + 2), texelFetch(mass_infos, index * 4 + 3).x);

	return result;
}




struct JointConstraint
{
	vec3 desired_dv;
	vec3 apply_pos;
	vec4 a_to_b;									// quaternion; b_to_a can be computed as the reverse of a_to_b

	mat3 oriented_axes;
	vec3 min_extents, max_extents;

	mat3 net_moi;									// alpha_to_obja = obj_a->inv_moi * net_moi; alpha_to_objb = obj_b->inv_moi * net_moi;
} jc;

void get_joint_constraint(int index, vec4 first_sample)
{
	vec4 samples[9] =
	{
		first_sample,
		texelFetch(constraint_data, index + 1),
		texelFetch(constraint_data, index + 2),
		texelFetch(constraint_data, index + 3),
		texelFetch(constraint_data, index + 4),
		texelFetch(constraint_data, index + 5),
		texelFetch(constraint_data, index + 6),
		texelFetch(constraint_data, index + 7),
		texelFetch(constraint_data, index + 8)		// samples[8].w is unused
	};

	jc.desired_dv =		first_sample.yzw;
	jc.apply_pos =		samples[1].xyz;
	jc.a_to_b =			samples[4].yzwx;

	jc.oriented_axes =	mat3(samples[1].w, samples[2], samples[3]);
	jc.min_extents =	samples[5].xyz;
	jc.max_extents =	samples[8].xyz;

	jc.net_moi =		mat3(samples[5].w, samples[6], samples[7]);
}

float jc_get_use_mass(vec3 direction, vec3 r1, vec3 r2)
{
	vec3 nr1 = cross(direction, r1);
	vec3 nr2 = cross(direction, r2);
	return 1.0 / (massinfo_a.inv_mass + massinfo_b.inv_mass + dot(massinfo_a.inv_moi * nr1, nr1) + dot(massinfo_b.inv_moi * nr2, nr2));
}

void process_joint_constraint(vec4 data_sample)
{
	get_joint_constraint(data_index, data_sample);

	vec3 r1 = jc.apply_pos - massinfo_a.com;
	vec3 r2 = jc.apply_pos - massinfo_b.com;

	// linear stuff
	vec3 current_dv = vel_b - vel_a + cross(r2, rot_b) - cross(r1, rot_a);
	vec3 dv = jc.desired_dv - current_dv;

	float dv_mag = length(dv);
	if(dv_mag > 0.0)
	{
		vec3 impulse = dv * (-JC_DV_COEFF * jc_get_use_mass(dv / dv_mag, r1, r2));

		vel_a += impulse * massinfo_a.inv_mass;
		rot_a += massinfo_a.inv_moi * cross(impulse, r1);

		vel_b -= impulse * massinfo_b.inv_mass;
		rot_b -= massinfo_b.inv_moi * cross(impulse, r2);
	}


	// angular stuff
	vec3 current_av = rot_b - rot_a;
	vec3 alpha = vec3(0.0, 0.0, 0.0);

#if ENFORCE_JOINT_ROTATION_LIMITS
	// enforce joint rotation limits
	vec3 proposed_av = current_av - alpha;
	vec4 proposed_ori = quat_multiply(jc.a_to_b, quat_from_scaled_axis(proposed_av * timestep));
	vec3 proposed_pyr = -quat_to_scaled_axis(proposed_ori) * jc.oriented_axes;

	bool any_changes = false;
	if      (proposed_pyr.x < jc.min_extents.x) { proposed_pyr.x = jc.min_extents.x; any_changes = true; }
	else if (proposed_pyr.x > jc.max_extents.x) { proposed_pyr.x = jc.max_extents.x; any_changes = true; }
	if      (proposed_pyr.y < jc.min_extents.y) { proposed_pyr.y = jc.min_extents.y; any_changes = true; }
	else if (proposed_pyr.y > jc.max_extents.y) { proposed_pyr.y = jc.max_extents.y; any_changes = true; }
	if      (proposed_pyr.z < jc.min_extents.z) { proposed_pyr.z = jc.min_extents.z; any_changes = true; }
	else if (proposed_pyr.z > jc.max_extents.z) { proposed_pyr.z = jc.max_extents.z; any_changes = true; }

	if(any_changes)
	{
		// at least one rotation limit was violated, so we must recompute alpha
		vec4 actual_ori = quat_from_scaled_axis(-jc.oriented_axes * proposed_pyr);
		vec3 actual_av = quat_to_scaled_axis(quat_multiply(vec4(-jc.a_to_b.xyz, jc.a_to_b.w), actual_ori)) / timestep;

		alpha = current_av - actual_av;
	}
#endif

	// apply angular velocity changes
	if(true)
	{
		rot_a += (massinfo_a.inv_moi * jc.net_moi) * alpha;
		rot_b -= (massinfo_b.inv_moi * jc.net_moi) * alpha;
	}
}




struct ContactPoint
{
	vec3 position;
	vec3 normal;
	vec3 r1, r2, nr1, nr2;

	float use_mass;
	float bounce_coeff;
	float fric_coeff;
} cp;

void get_contact_point(int index, vec4 first_sample)
{
	vec4 samples[6] =
	{
		first_sample,
		texelFetch(constraint_data, index + 1),
		texelFetch(constraint_data, index + 2),
		texelFetch(constraint_data, index + 3),
		texelFetch(constraint_data, index + 4),		// samples[4].w is unused
		texelFetch(constraint_data, index + 5)		// samples[5].w is unused
	};

	cp.position =		samples[5].xyz;
	cp.normal =			samples[1].xyz;
	cp.r1 =				samples[2].xyz;
	cp.r2 =				samples[3].xyz;
	cp.nr1 =			samples[4].xyz;
	cp.nr2 = 			vec3(samples[1].w, samples[2].w, samples[3].w);

	cp.use_mass = 		first_sample.y;
	cp.bounce_coeff =	first_sample.z;
	cp.fric_coeff =		first_sample.w;
}

vec3	cp_get_relative_local_velocity()	{ return vel_b - vel_a + cross(cp.r2, rot_b) - cross(cp.r1, rot_a); }

float	cp_get_inward_velocity()			{ return dot(vel_a - vel_b, cp.normal) + dot(rot_a, cp.nr1) - dot(rot_b, cp.nr2); }

float	cp_get_use_mass(vec3 direction)
{
	vec3 nr1 = cross(direction, cp.position - massinfo_a.com);
	vec3 nr2 = cross(direction, cp.position - massinfo_b.com);
	return 1.0 / (massinfo_a.inv_mass + massinfo_b.inv_mass + dot(massinfo_a.inv_moi * nr1, nr1) + dot(massinfo_b.inv_moi * nr2, nr2));
}

void	cp_apply_impulse(vec3 impulse)
{
	vel_a += impulse * massinfo_a.inv_mass;
	rot_a += massinfo_a.inv_moi * cross(impulse, cp.r1);

	vel_b -= impulse * massinfo_b.inv_mass;
	rot_b -= massinfo_b.inv_moi * cross(impulse, cp.r2);
}

void process_contact_point(vec4 data_sample)
{
	get_contact_point(data_index, data_sample);

	vec3 dv = cp_get_relative_local_velocity();
	float nvdot = dot(cp.normal, dv);
	if(nvdot < 0.0)
	{
		float impulse_mag = cp.bounce_coeff * cp_get_inward_velocity() * cp.use_mass;
		if(impulse_mag < 0.0)
		{
			vec3 impulse = cp.normal * impulse_mag;

			// normal force
			if(true)		// TODO: have a condition maybe?
			{
				cp_apply_impulse(impulse);

				dv = cp_get_relative_local_velocity();
				nvdot = dot(cp.normal, dv);
			}

			vec3 t_dv = dv - cp.normal * nvdot;
			float t_dv_mag = length(t_dv);

			// linear friction (kinetic)
			if(t_dv_mag > 0.0)
			{
				float inv_tdmag = 1.0 / t_dv_mag;
				float use_mass2 = cp_get_use_mass(t_dv * inv_tdmag);

				cp_apply_impulse(t_dv * min(use_mass2, abs(impulse_mag * cp.fric_coeff * inv_tdmag)));
			}
		}
	}
}




vec3 get_vel(int index) { return texelFetch(velocity_data, index + num_rigid_bodies).xyz; }
vec3 get_rot(int index) { return texelFetch(velocity_data, index).xyz; }

void main()
{
	int use_id = gl_VertexID % num_rigid_bodies;

	out_rot = texelFetch(velocity_data, use_id);
	out_vel = texelFetch(velocity_data, use_id + num_rigid_bodies);

	data_index = int(constraint_data_index);

	if(data_index != 0)
	{
		--data_index;

		index_a = int(object_indices[0]);
		index_b = int(object_indices[1]);

		vel_a = get_vel(index_a);
		rot_a = get_rot(index_a);

		vel_b = get_vel(index_b);
		rot_b = get_rot(index_b);

		massinfo_a = get_mass_info(index_a);
		massinfo_b = get_mass_info(index_b);

		vec4 data_sample = texelFetch(constraint_data, data_index);

		if(data_sample.x > 0)
			process_contact_point   (data_sample);
		else
			process_joint_constraint(data_sample);

		if(index_a == use_id)
		{
			out_vel.xyz = vel_a;
			out_rot.xyz = rot_a;
		}
		else
		{
			out_vel.xyz = vel_b;
			out_rot.xyz = rot_b;
		}
	}
}
