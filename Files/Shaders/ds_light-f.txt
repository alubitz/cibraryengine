#extension GL_EXT_gpu_shader4 : enable

#define ENABLE_SHADOWS 1
#define N_SHADOW_MAPS 3

varying	vec3			position;

uniform	sampler2D		diffuse, normal, specular, depth;
uniform	float			camera_near, camera_far;

uniform	mat4			inv_view_matrix;

vec3 cameraVecToWorld(vec3 v) { return (vec4(v, 0.0) * inv_view_matrix).xyz; }
vec3 cameraPosToWorld(vec3 v) { vec4 temp = vec4(v, 1.0) * inv_view_matrix; return temp.xyz / temp.w; }

#if ENABLE_SHADOWS

	uniform	sampler2D[N_SHADOW_MAPS]	shadow_depths;
	uniform	mat4     [N_SHADOW_MAPS]	shadow_matrices, inv_shadow_matrices;

	uniform	float						shadow_near, shadow_far;

	vec3 worldToShadow(int index, vec3 v) { vec4 temp = vec4(v, 1.0) *     shadow_matrices[index]; return temp.xyz / temp.w; }
	vec3 shadowToWorld(int index, vec3 v) { vec4 temp = vec4(v, 1.0) * inv_shadow_matrices[index]; return temp.xyz / temp.w; }

	float getDepthSample(int index, vec2 shadow_coord)
	{
		if(index == 0)
			return texture2D(shadow_depths[0], shadow_coord * 0.5 + 0.5).x;
		else if(index == 1)
			return texture2D(shadow_depths[1], shadow_coord * 0.5 + 0.5).x;
		else
			return texture2D(shadow_depths[2], shadow_coord * 0.5 + 0.5).x;
	}

	bool getUnshadowedAmount(int index, vec3 uLight, vec3 world_pos, inout float brightness)
	{
		vec3 shadow_coord = worldToShadow(index, world_pos);
		if(abs(shadow_coord.x) <= 1.0 && abs(shadow_coord.y) <= 1.0)
		{
			float depth_sample = getDepthSample(index, shadow_coord.xy);
			float shadow_z = depth_sample * (shadow_far - shadow_near) + shadow_near;				// don't use depth_to_z for an orthographic shadow map
			vec3 shadow_pos = shadowToWorld(index, vec3(shadow_coord.xy, -shadow_z));

			float distance_past_shadow = dot(cameraVecToWorld(uLight), shadow_pos - world_pos);
			brightness = distance_past_shadow < 0.0 ? 1.0 : 0.0;
			return true;
		}
		else
			return false;
	}

#endif

float depth_to_z(float depth_value, float near, float far)
{
	float temp = 2.0 * depth_value - 1.0;
	return 2.0 * near * far / (far + near - temp * (far - near));
}

void main()
{
	gl_FragColor.w = 1.0;

	vec2 uv = gl_TexCoord[0].xy;

	float z = depth_to_z(texture2D(depth, uv).x, camera_near, camera_far);
	vec3 pos = vec3(position.xy * z, -z);
	vec3 uPos = normalize(pos);

	vec3 world_pos = cameraPosToWorld(pos);
	vec3 uLight = normalize(gl_LightSource[0].position.xyz);

#if ENABLE_SHADOWS

	float brightness = 1.0;
	for(int i = 0; i < N_SHADOW_MAPS; ++i)
	{
		if(getUnshadowedAmount(i, uLight, world_pos, brightness))
			break;
	}

	if(brightness > 0.0)
	{

#endif
		vec4 normal_sample = texture2D(normal, uv);
		vec4 diffuse_sample = texture2D(diffuse, uv);
		vec4 specular_sample = texture2D(specular, uv);

		vec3 uNorm = normal_sample.xyz * 2.0 - 1.0;

		float light_dot = dot(uNorm, uLight);
		float eye_dot = dot(uNorm, uPos);
		vec3 uBounce = uPos - (2.0 * eye_dot) * uNorm;

		float diffuse_amount = max(0.0, min(1.0, light_dot));

		float specular_dot = dot(uBounce, uLight);
		float specular_base = max(0.0, min(1.0, specular_dot));
		float specular_amount = pow(specular_base, 4.0);

		vec3 diffuse_color = diffuse_sample.xyz;
		vec3 specular_color = specular_sample.xyz;

		vec3 base_color = diffuse_color * diffuse_amount * gl_LightSource[0].diffuse.xyz + specular_color * specular_amount * gl_LightSource[0].specular.xyz;

#if ENABLE_SHADOWS
		gl_FragColor.xyz = base_color * brightness;
	}
	else
		discard;
#else
	gl_FragColor.xyz = base_color;
#endif
}
